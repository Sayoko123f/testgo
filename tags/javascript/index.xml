<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>JavaScript on My New Hugo Site</title><link>https://sayoko123f.github.io/testgo/tags/javascript/</link><description>Recent content in JavaScript on My New Hugo Site</description><generator>Hugo -- gohugo.io</generator><language>zh-TW</language><lastBuildDate>Sun, 05 Jun 2022 09:49:47 +0800</lastBuildDate><atom:link href="https://sayoko123f.github.io/testgo/tags/javascript/index.xml" rel="self" type="application/rss+xml"/><item><title>Intersection Observer</title><link>https://sayoko123f.github.io/testgo/p/intersection-observer/</link><pubDate>Sun, 05 Jun 2022 09:49:47 +0800</pubDate><guid>https://sayoko123f.github.io/testgo/p/intersection-observer/</guid><description>JavaScript Intersection Observer API 筆記 Intersection Observer(以下稱交集觀察者或觀察者) 筆記。
常用屬性跟方法 IntersectionObserverEntry.intersectionRatio 描述元素可見的比例，為範圍 1.0 至 0.0 之間的數字。
IntersectionObserverEntry.target 指向被觀察的目標元素。
IntersectionObserverEntry.isIntersecting 一個 Boolean 值，如果目標元素處於相交狀態則為 true，反之為 false。
IntersectionObserver.observe() 傳入 Element 開始觀察。
observe(targetElement) 該元素必須是 IntersectionObserver.root 元素的後代。
IntersectionObserver.unobserve() 停止觀察該元素。
unobserve(target) 就算該元素不是正在被觀察也不會拋出任何錯誤。
IntersectionObserver.disconnect() 停止觀察所有元素。
IntersectionObserver() MDN
建立觀察者實例的建構函式。
new IntersectionObserver(callback) new IntersectionObserver(callback, options) 有兩個引數會被傳入 callback ：
第一引數是 IntersectionObserverEntry[]；
第二引數是 IntersectionObserver 觀察者的實例；
callback 起手式如下：
function handleIntersect(entries, observer) { entries.forEach((entry) =&amp;gt; { const { target } = entry; if (entry.</description></item><item><title>JavaScript 網頁無限下拉滾動效果 - Intersection Observer</title><link>https://sayoko123f.github.io/testgo/p/javascript-intersection-observer-infinite-scroll/</link><pubDate>Mon, 30 May 2022 20:42:23 +0800</pubDate><guid>https://sayoko123f.github.io/testgo/p/javascript-intersection-observer-infinite-scroll/</guid><description>JavaScript 網頁無限下拉滾動效果 - Intersection Observer 本文將會使用 Intersection Observer (以下稱觀察者) 來實現具有無限下拉滾動效果的網頁。
本文全土法炮製，未引用任何函式庫。
Dog API 介接 Dog API ，這個 API 會傳回隨機的狗狗圖片網址。
/** * Get dog image url. * @param {number} num * @returns {Promise&amp;lt;string[]&amp;gt;} */ async function getDogImages(num = 1) { const url = `https://dog.ceo/api/breeds/image/random/${num}`; const res = await fetch(url); const json = await res.json(); return json.message; } 前置作業 先準備一段 HTML 跟 CSS ：
&amp;lt;main class=&amp;#34;main-container&amp;#34; id=&amp;#34;main&amp;#34;&amp;gt;&amp;lt;/main&amp;gt; .</description></item><item><title>JavaScript Intersection Observer API 筆記</title><link>https://sayoko123f.github.io/testgo/p/javascript-intersection-observer/</link><pubDate>Sat, 28 May 2022 10:08:48 +0800</pubDate><guid>https://sayoko123f.github.io/testgo/p/javascript-intersection-observer/</guid><description>JavaScript Intersection Observer API 筆記 Intersection Observer(以下稱交集觀察者或觀察者) 筆記。
常用屬性跟方法 IntersectionObserverEntry.intersectionRatio 描述元素可見的比例，為範圍 1.0 至 0.0 之間的數字。
IntersectionObserverEntry.target 指向被觀察的目標元素。
IntersectionObserverEntry.isIntersecting 一個 Boolean 值，如果目標元素處於相交狀態則為 true，反之為 false。
IntersectionObserver.observe() 傳入 Element 開始觀察。
observe(targetElement) 該元素必須是 IntersectionObserver.root 元素的後代。
IntersectionObserver.unobserve() 停止觀察該元素。
unobserve(target) 就算該元素不是正在被觀察也不會拋出任何錯誤。
IntersectionObserver.disconnect() 停止觀察所有元素。
IntersectionObserver() MDN
建立觀察者實例的建構函式。
new IntersectionObserver(callback) new IntersectionObserver(callback, options) 有兩個引數會被傳入 callback ：
第一引數是 IntersectionObserverEntry[]；
第二引數是 IntersectionObserver 觀察者的實例；
callback 起手式如下：
function handleIntersect(entries, observer) { entries.forEach((entry) =&amp;gt; { const { target } = entry; if (entry.</description></item><item><title>JavaScript 視需要動態地載入 Script 和 CSS</title><link>https://sayoko123f.github.io/testgo/p/javascript-lazyload-script-or-css/</link><pubDate>Wed, 18 May 2022 20:49:52 +0800</pubDate><guid>https://sayoko123f.github.io/testgo/p/javascript-lazyload-script-or-css/</guid><description>視需要動態地載入 Script 和 CSS Script 有的時候，某些 Script 檔案的功能不需要馬上用到或是根本不太常用，如果放在 Head 裡面，就浪費了一點載入的時間，這種時候就適合使用動態載入的方式。底下包成一個回傳 Promise 的函式：
function importScript(url) { return new Promise((resolve, reject) =&amp;gt; { let s = document.createElement(&amp;#39;script&amp;#39;); s.onload = () =&amp;gt; { resolve(); }; s.onerror = (e) =&amp;gt; { reject(e); }; s.src = url; document.head.appendChild(s); }) } CSS function importCSS(url) { return new Promise((resolve, reject) =&amp;gt; { let l = document.createElement(&amp;#39;link&amp;#39;); l.onload = () =&amp;gt; { resolve(); }; l.</description></item><item><title>ES6 模組 import 和 export 的用法</title><link>https://sayoko123f.github.io/testgo/p/about-import-and-export-in-es6-module/</link><pubDate>Tue, 15 Mar 2022 18:20:26 +0800</pubDate><guid>https://sayoko123f.github.io/testgo/p/about-import-and-export-in-es6-module/</guid><description>ES6 模組 import 和 export 的用法 import/export 是 ES6 加入的關鍵字，用來匯入和匯出模組，以一個檔案為單位，每個檔案自成一個模組，模組可以匯出值、函式及類別供其它檔案匯入使用。
匯出和匯入的用法 匯出/匯入有兩種形式：「命名匯出/匯入」和「預設匯出/匯入」。在下方示範程式碼中，所有檔案皆放在同一層資料夾。
命名匯出 如果想要匯出東西，在宣告前面加上 export 即可命名匯出。
// filename: &amp;#34;test1.js&amp;#34; export const hello = &amp;#39;hello world&amp;#39;; export function plus(a, b) { return a + b; } export class Animal{ constructor(name) { /*something*/ } } 除了在每個宣告前方加上 export ，也可以在檔案的結尾一次性匯出，這兩種匯出的匯入方式相同。
// filename: &amp;#34;test1.js&amp;#34; const hello = &amp;#39;hello world&amp;#39;; function plus(a, b) { return a + b; } class Animal { constructor(name) { this.</description></item><item><title>JavaScript 關於錯誤處理與自訂錯誤類別</title><link>https://sayoko123f.github.io/testgo/p/javascript-error/</link><pubDate>Sun, 10 Oct 2021 11:49:39 +0800</pubDate><guid>https://sayoko123f.github.io/testgo/p/javascript-error/</guid><description>JavaScript 關於錯誤處理與自訂錯誤類別 關於錯誤 在 JavaScript 中，內建有 Error 類別，詳細請見 MDN。先來看看錯誤長什麼樣子，下方程式碼引發一個 SyntaxError
JSON.parse(&amp;#39;foo&amp;#39;); 在主控台會看到這段訊息
VM252:1 Uncaught SyntaxError: Unexpected token o in JSON at position 1 at JSON.parse (&amp;lt;anonymous&amp;gt;) at test.js:1 捕捉錯誤並檢視訊息 可利用 try/catch 語句捕捉錯誤，錯誤物件的 name 和 message 特性包含錯誤的名字與訊息，toString() 方法會回傳一段包含 name 跟 message 的字串。如果想要檢視呼叫堆疊，可以使用 console.trace() 。
try { JSON.parse(&amp;#39;foo&amp;#39;); } catch (err) { console.log(err.name); // SyntaxError console.log(err.message); // Unexpected token o in JSON at position 1 console.log(err.toString()); // SyntaxError: Unexpected token o in JSON at position 1 console.</description></item><item><title>JavaScript Onbeforeunload</title><link>https://sayoko123f.github.io/testgo/p/javascript-onbeforeunload/</link><pubDate>Fri, 21 May 2021 09:34:20 +0800</pubDate><guid>https://sayoko123f.github.io/testgo/p/javascript-onbeforeunload/</guid><description>在離開頁面之前詢問使用者是否要離開 WindowEventHandlers.onbeforeunload MDN
window.onbeforeunload 這樣寫即可。
window.onbeforeunload = function () { return &amp;#34;&amp;#34;; } 為防止詐騙，各大瀏覽器已不支援自訂訊息 // Deprecated window.onbeforeunload = function() { if(!confirm(&amp;#39;您確定要離開網頁嗎？&amp;#39;)) { return false; } } 在以前可能會這樣寫，雖然這樣寫功能仍可以正常運作，但為了防止詐騙，現在瀏覽器已經不支援自訂訊息了，所以只會看到瀏覽器預設的訊息。</description></item><item><title>JavaScript 如何動態地插入元素至 DOM</title><link>https://sayoko123f.github.io/testgo/p/javascript-insert-element-to-dom/</link><pubDate>Thu, 20 May 2021 09:52:56 +0800</pubDate><guid>https://sayoko123f.github.io/testgo/p/javascript-insert-element-to-dom/</guid><description>如何動態地插入元素至 DOM 先備知識 建議已經對 HTML DOM 有基本了解的讀者再閱讀底下內容。
節點關係 考慮以下 HTML：&amp;lt;body&amp;gt; 底下有 id=&amp;quot;box&amp;quot; 的 &amp;lt;div&amp;gt;，底下又有 4 顆 button。 button 在 div 底下，所以 button 是 div 的子節點， div 是 button 的父節點，稱為父子關係。而 4顆 button 之間彼此是兄弟關係。
&amp;lt;!DOCTYPE html&amp;gt; &amp;lt;html&amp;gt; &amp;lt;head&amp;gt; &amp;lt;meta charset=&amp;#34;UTF-8&amp;#34;&amp;gt; &amp;lt;title&amp;gt;Document&amp;lt;/title&amp;gt; &amp;lt;/head&amp;gt; &amp;lt;body&amp;gt; &amp;lt;div id=&amp;#34;box&amp;#34;&amp;gt; &amp;lt;button id=&amp;#34;btn1&amp;#34;&amp;gt;btn1&amp;lt;/button&amp;gt; &amp;lt;button id=&amp;#34;btn2&amp;#34;&amp;gt;btn2&amp;lt;/button&amp;gt; &amp;lt;button id=&amp;#34;btn3&amp;#34;&amp;gt;btn3&amp;lt;/button&amp;gt; &amp;lt;button id=&amp;#34;btn4&amp;#34;&amp;gt;btn4&amp;lt;/button&amp;gt; &amp;lt;/div&amp;gt; &amp;lt;/body&amp;gt; &amp;lt;/html&amp;gt; 透過父子關係或兄弟關係選擇元素 繼續用上面的 HTML：
let box = document.</description></item><item><title>如何使用 JavaScript 切換元素的 class</title><link>https://sayoko123f.github.io/testgo/p/javascript-toggle-class/</link><pubDate>Thu, 13 May 2021 10:16:52 +0800</pubDate><guid>https://sayoko123f.github.io/testgo/p/javascript-toggle-class/</guid><description>如何使用 JavaScript 切換元素的 class 利用 element.classList即可，底下來看看如何使用：
&amp;lt;!-- html --&amp;gt; &amp;lt;p id=&amp;#34;p1&amp;#34;&amp;gt;Hello World!&amp;lt;/p&amp;gt; /* css */ .blue{ color: blue; } .red{ color: red; } .green{ color: green; } element.classList element.classList 包含了這個元素所有的類別名稱的物件。
let p1 = document.getElementById(&amp;#39;p1&amp;#39;); // 後面的範例都省略這行 p1.classList; // { length: 0, value: &amp;#34;&amp;#34;} p1.classList.length === 0; // true p1.classList.add(&amp;#39;red&amp;#39;); p1.classList; // {0: &amp;#34;red&amp;#34;, length: 1, value: &amp;#34;red&amp;#34;} p1.classList[0]; // &amp;#34;red&amp;#34; classList.add(classname) 傳入類別名稱就會添加類別至元素上，如果已經有了則什麼事都不會發生。
p1.classList.add(&amp;#39;blue&amp;#39;); classList.contains(classname) 傳入類別名稱，傳回 boolean，如果存在該類名就是 true，反之 false。</description></item></channel></rss>