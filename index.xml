<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>首頁 on My New Hugo Site</title><link>https://sayoko123f.github.io/testgo/</link><description>Recent content in 首頁 on My New Hugo Site</description><generator>Hugo -- gohugo.io</generator><language>zh-TW</language><lastBuildDate>Mon, 06 Jun 2022 17:02:30 +0800</lastBuildDate><atom:link href="https://sayoko123f.github.io/testgo/index.xml" rel="self" type="application/rss+xml"/><item><title>Test17</title><link>https://sayoko123f.github.io/testgo/p/test17/</link><pubDate>Mon, 06 Jun 2022 17:02:30 +0800</pubDate><guid>https://sayoko123f.github.io/testgo/p/test17/</guid><description>Test17 測試測試測試測試測試測試測試測試測試測試測試測試測試測試測試，測試測試測試測試測試測試測試測試測試。</description></item><item><title>Test16</title><link>https://sayoko123f.github.io/testgo/p/test16/</link><pubDate>Mon, 06 Jun 2022 17:02:28 +0800</pubDate><guid>https://sayoko123f.github.io/testgo/p/test16/</guid><description>Test16 測試測試測試測試測試測試測試測試測試測試測試測試測試測試測試，測試測試測試測試測試測試測試測試測試。</description></item><item><title>Test15</title><link>https://sayoko123f.github.io/testgo/p/test15/</link><pubDate>Mon, 06 Jun 2022 17:02:27 +0800</pubDate><guid>https://sayoko123f.github.io/testgo/p/test15/</guid><description>Test15 測試測試測試測試測試測試測試測試測試測試測試測試測試測試測試，測試測試測試測試測試測試測試測試測試。</description></item><item><title>Test14</title><link>https://sayoko123f.github.io/testgo/p/test14/</link><pubDate>Mon, 06 Jun 2022 17:02:26 +0800</pubDate><guid>https://sayoko123f.github.io/testgo/p/test14/</guid><description>Test14 測試測試測試測試測試測試測試測試測試測試測試測試測試測試測試，測試測試測試測試測試測試測試測試測試。</description></item><item><title>Test13</title><link>https://sayoko123f.github.io/testgo/p/test13/</link><pubDate>Mon, 06 Jun 2022 17:02:24 +0800</pubDate><guid>https://sayoko123f.github.io/testgo/p/test13/</guid><description>Test13 測試測試測試測試測試測試測試測試測試測試測試測試測試測試測試，測試測試測試測試測試測試測試測試測試。</description></item><item><title>Test12</title><link>https://sayoko123f.github.io/testgo/p/test12/</link><pubDate>Mon, 06 Jun 2022 17:02:23 +0800</pubDate><guid>https://sayoko123f.github.io/testgo/p/test12/</guid><description>Test12 測試測試測試測試測試測試測試測試測試測試測試測試測試測試測試，測試測試測試測試測試測試測試測試測試。</description></item><item><title>Test11</title><link>https://sayoko123f.github.io/testgo/p/test11/</link><pubDate>Mon, 06 Jun 2022 17:02:21 +0800</pubDate><guid>https://sayoko123f.github.io/testgo/p/test11/</guid><description>Test11 測試測試測試測試測試測試測試測試測試測試測試測試測試測試測試，測試測試測試測試測試測試測試測試測試。</description></item><item><title>Test10</title><link>https://sayoko123f.github.io/testgo/p/test10/</link><pubDate>Mon, 06 Jun 2022 17:02:20 +0800</pubDate><guid>https://sayoko123f.github.io/testgo/p/test10/</guid><description>Test10 測試測試測試測試測試測試測試測試測試測試測試測試測試測試測試，測試測試測試測試測試測試測試測試測試。</description></item><item><title>Test8</title><link>https://sayoko123f.github.io/testgo/p/test8/</link><pubDate>Mon, 06 Jun 2022 16:49:28 +0800</pubDate><guid>https://sayoko123f.github.io/testgo/p/test8/</guid><description>Test8 測試測試測試測試測試測試測試測試測試測試測試測試測試測試測試，測試測試測試測試測試測試測試測試測試。</description></item><item><title>Test7</title><link>https://sayoko123f.github.io/testgo/p/test7/</link><pubDate>Mon, 06 Jun 2022 16:49:03 +0800</pubDate><guid>https://sayoko123f.github.io/testgo/p/test7/</guid><description>Test7 測試測試測試測試測試測試測試測試測試測試測試測試測試測試測試，測試測試測試測試測試測試測試測試測試。</description></item><item><title>Test6</title><link>https://sayoko123f.github.io/testgo/p/test6/</link><pubDate>Mon, 06 Jun 2022 16:48:36 +0800</pubDate><guid>https://sayoko123f.github.io/testgo/p/test6/</guid><description>Test6 測試測試測試測試測試測試測試測試測試測試測試測試測試測試測試，測試測試測試測試測試測試測試測試測試。</description></item><item><title>Intersection Observer</title><link>https://sayoko123f.github.io/testgo/p/intersection-observer/</link><pubDate>Sun, 05 Jun 2022 09:49:47 +0800</pubDate><guid>https://sayoko123f.github.io/testgo/p/intersection-observer/</guid><description>JavaScript Intersection Observer API 筆記 Intersection Observer(以下稱交集觀察者或觀察者) 筆記。
常用屬性跟方法 IntersectionObserverEntry.intersectionRatio 描述元素可見的比例，為範圍 1.0 至 0.0 之間的數字。
IntersectionObserverEntry.target 指向被觀察的目標元素。
IntersectionObserverEntry.isIntersecting 一個 Boolean 值，如果目標元素處於相交狀態則為 true，反之為 false。
IntersectionObserver.observe() 傳入 Element 開始觀察。
observe(targetElement) 該元素必須是 IntersectionObserver.root 元素的後代。
IntersectionObserver.unobserve() 停止觀察該元素。
unobserve(target) 就算該元素不是正在被觀察也不會拋出任何錯誤。
IntersectionObserver.disconnect() 停止觀察所有元素。
IntersectionObserver() MDN
建立觀察者實例的建構函式。
new IntersectionObserver(callback) new IntersectionObserver(callback, options) 有兩個引數會被傳入 callback ：
第一引數是 IntersectionObserverEntry[]；
第二引數是 IntersectionObserver 觀察者的實例；
callback 起手式如下：
function handleIntersect(entries, observer) { entries.forEach((entry) =&amp;gt; { const { target } = entry; if (entry.</description></item><item><title>如何將多個 ts 檔案合併為一個 mp4 檔案</title><link>https://sayoko123f.github.io/testgo/p/ffmpeg-m3u8-ts-to-mp4/</link><pubDate>Sun, 05 Jun 2022 09:18:43 +0800</pubDate><guid>https://sayoko123f.github.io/testgo/p/ffmpeg-m3u8-ts-to-mp4/</guid><description>如何將多個 ts 檔案合併為一個 mp4 檔案 下載 ffmpeg How to install ffmpeg
ffmpeg build
選 release builds，ffmpeg-release-full-shared.7z 版本，功能齊全但檔案稍微大一點。
下載好後解壓縮，將 ffmpeg/bin 加入環境變數。
打開 cmd 輸入 ffmpeg 看看是否有成功。
合併 ts 並轉換 For Windows 先將多個 ts 合併成一個：
copy /b 0.ts+1.ts+2.ts+3.ts all.ts 然後使用 ffmpeg 轉換：
ffmpeg -i all.ts -acodec copy -vcodec copy all.mp4 大功告成。
參考 Use ffmpeg copy codec to combine *.ts files into a single mp4
附錄- Node 下載 ts 檔案 npm install axios import axios from &amp;#34;axios&amp;#34;; import * as fs from &amp;#34;fs&amp;#34;; import { promisify } from &amp;#34;util&amp;#34;; import stream from &amp;#34;stream&amp;#34;; const finished = promisify(stream.</description></item><item><title>Foobar</title><link>https://sayoko123f.github.io/testgo/p/foobar/</link><pubDate>Fri, 03 Jun 2022 13:35:36 +0800</pubDate><guid>https://sayoko123f.github.io/testgo/p/foobar/</guid><description>&lt;p>你好，這裡是端午節，今天天氣晴朗；你好，這裡是端午節，今天天氣晴朗；你好，這裡是端午節，今天天氣晴朗；你好，這裡是端午節，今天天氣晴朗；你好，這裡是端午節，今天天氣晴朗；你好，這裡是端午節，今天天氣晴朗；你好，這裡是端午節，今天天氣晴朗；你好，這裡是端午節，今天天氣晴朗；你好，這裡是端午節，今天天氣晴朗；你好，這裡是端午節，今天天氣晴朗&lt;/p></description></item><item><title>JavaScript 網頁無限下拉滾動效果 - Intersection Observer</title><link>https://sayoko123f.github.io/testgo/p/javascript-intersection-observer-infinite-scroll/</link><pubDate>Mon, 30 May 2022 20:42:23 +0800</pubDate><guid>https://sayoko123f.github.io/testgo/p/javascript-intersection-observer-infinite-scroll/</guid><description>JavaScript 網頁無限下拉滾動效果 - Intersection Observer 本文將會使用 Intersection Observer (以下稱觀察者) 來實現具有無限下拉滾動效果的網頁。
本文全土法炮製，未引用任何函式庫。
Dog API 介接 Dog API ，這個 API 會傳回隨機的狗狗圖片網址。
/** * Get dog image url. * @param {number} num * @returns {Promise&amp;lt;string[]&amp;gt;} */ async function getDogImages(num = 1) { const url = `https://dog.ceo/api/breeds/image/random/${num}`; const res = await fetch(url); const json = await res.json(); return json.message; } 前置作業 先準備一段 HTML 跟 CSS ：
&amp;lt;main class=&amp;#34;main-container&amp;#34; id=&amp;#34;main&amp;#34;&amp;gt;&amp;lt;/main&amp;gt; .</description></item><item><title>分類</title><link>https://sayoko123f.github.io/testgo/tags/</link><pubDate>Mon, 30 May 2022 12:47:48 +0800</pubDate><guid>https://sayoko123f.github.io/testgo/tags/</guid><description/></item><item><title>關於</title><link>https://sayoko123f.github.io/testgo/about/</link><pubDate>Mon, 30 May 2022 12:47:48 +0800</pubDate><guid>https://sayoko123f.github.io/testgo/about/</guid><description>關於 你好
關於本站 const hi = &amp;#39;hello&amp;#39;;</description></item><item><title>Tettttt</title><link>https://sayoko123f.github.io/testgo/p/tettttt/</link><pubDate>Mon, 30 May 2022 12:41:48 +0800</pubDate><guid>https://sayoko123f.github.io/testgo/p/tettttt/</guid><description>&lt;p>這是一段摘要&lt;strong>預覽&lt;/strong>內容&lt;/p></description></item><item><title>Action Test</title><link>https://sayoko123f.github.io/testgo/p/action-test/</link><pubDate>Sun, 29 May 2022 17:23:41 +0800</pubDate><guid>https://sayoko123f.github.io/testgo/p/action-test/</guid><description>&lt;p>Lorem ipsum dolor sit amet consectetur adipisicing elit. Dolores eaque reprehenderit eius amet, incidunt corrupti omnis. Odio maiores assumenda iusto ducimus ipsa voluptas? Ex impedit libero laborum dignissimos asperiores facilis!&lt;/p></description></item><item><title>Hi Title</title><link>https://sayoko123f.github.io/testgo/p/hi/</link><pubDate>Sun, 29 May 2022 16:36:43 +0800</pubDate><guid>https://sayoko123f.github.io/testgo/p/hi/</guid><description>Hi Hello</description></item><item><title>JavaScript Intersection Observer API 筆記</title><link>https://sayoko123f.github.io/testgo/p/javascript-intersection-observer/</link><pubDate>Sat, 28 May 2022 10:08:48 +0800</pubDate><guid>https://sayoko123f.github.io/testgo/p/javascript-intersection-observer/</guid><description>JavaScript Intersection Observer API 筆記 Intersection Observer(以下稱交集觀察者或觀察者) 筆記。
常用屬性跟方法 IntersectionObserverEntry.intersectionRatio 描述元素可見的比例，為範圍 1.0 至 0.0 之間的數字。
IntersectionObserverEntry.target 指向被觀察的目標元素。
IntersectionObserverEntry.isIntersecting 一個 Boolean 值，如果目標元素處於相交狀態則為 true，反之為 false。
IntersectionObserver.observe() 傳入 Element 開始觀察。
observe(targetElement) 該元素必須是 IntersectionObserver.root 元素的後代。
IntersectionObserver.unobserve() 停止觀察該元素。
unobserve(target) 就算該元素不是正在被觀察也不會拋出任何錯誤。
IntersectionObserver.disconnect() 停止觀察所有元素。
IntersectionObserver() MDN
建立觀察者實例的建構函式。
new IntersectionObserver(callback) new IntersectionObserver(callback, options) 有兩個引數會被傳入 callback ：
第一引數是 IntersectionObserverEntry[]；
第二引數是 IntersectionObserver 觀察者的實例；
callback 起手式如下：
function handleIntersect(entries, observer) { entries.forEach((entry) =&amp;gt; { const { target } = entry; if (entry.</description></item><item><title>JavaScript 視需要動態地載入 Script 和 CSS</title><link>https://sayoko123f.github.io/testgo/p/javascript-lazyload-script-or-css/</link><pubDate>Wed, 18 May 2022 20:49:52 +0800</pubDate><guid>https://sayoko123f.github.io/testgo/p/javascript-lazyload-script-or-css/</guid><description>視需要動態地載入 Script 和 CSS Script 有的時候，某些 Script 檔案的功能不需要馬上用到或是根本不太常用，如果放在 Head 裡面，就浪費了一點載入的時間，這種時候就適合使用動態載入的方式。底下包成一個回傳 Promise 的函式：
function importScript(url) { return new Promise((resolve, reject) =&amp;gt; { let s = document.createElement(&amp;#39;script&amp;#39;); s.onload = () =&amp;gt; { resolve(); }; s.onerror = (e) =&amp;gt; { reject(e); }; s.src = url; document.head.appendChild(s); }) } CSS function importCSS(url) { return new Promise((resolve, reject) =&amp;gt; { let l = document.createElement(&amp;#39;link&amp;#39;); l.onload = () =&amp;gt; { resolve(); }; l.</description></item><item><title>Vite + Vue + TypeScript + Tailwindcss 起手式</title><link>https://sayoko123f.github.io/testgo/p/vite-vue-typescript-tailwindcss-template/</link><pubDate>Sat, 30 Apr 2022 16:32:38 +0800</pubDate><guid>https://sayoko123f.github.io/testgo/p/vite-vue-typescript-tailwindcss-template/</guid><description>Vite + Vue + TypeScript + Tailwindcss 起手式 文件 本筆記提到的 Vue 與 Vue 插件都為 Vue 3!
create-vite
Tailwindcss install guide
tsconfig
指令 使用 create-vite 安裝 vue-ts 模板
npm create vite@latest my-vue-app -- --template vue-ts cd my-vue-app npm install 安裝 Tailwind
npm install -D tailwindcss postcss autoprefixer npx tailwindcss init -p Tailwindcss 設定檔案 tailwind.config.js
module.exports = { content: [ &amp;#34;./index.html&amp;#34;, &amp;#34;./src/**/*.{vue,js,ts,jsx,tsx}&amp;#34;, ], theme: { extend: {}, }, plugins: [], } 建立 .</description></item><item><title>ES6 模組 import 和 export 的用法</title><link>https://sayoko123f.github.io/testgo/p/about-import-and-export-in-es6-module/</link><pubDate>Tue, 15 Mar 2022 18:20:26 +0800</pubDate><guid>https://sayoko123f.github.io/testgo/p/about-import-and-export-in-es6-module/</guid><description>ES6 模組 import 和 export 的用法 import/export 是 ES6 加入的關鍵字，用來匯入和匯出模組，以一個檔案為單位，每個檔案自成一個模組，模組可以匯出值、函式及類別供其它檔案匯入使用。
匯出和匯入的用法 匯出/匯入有兩種形式：「命名匯出/匯入」和「預設匯出/匯入」。在下方示範程式碼中，所有檔案皆放在同一層資料夾。
命名匯出 如果想要匯出東西，在宣告前面加上 export 即可命名匯出。
// filename: &amp;#34;test1.js&amp;#34; export const hello = &amp;#39;hello world&amp;#39;; export function plus(a, b) { return a + b; } export class Animal{ constructor(name) { /*something*/ } } 除了在每個宣告前方加上 export ，也可以在檔案的結尾一次性匯出，這兩種匯出的匯入方式相同。
// filename: &amp;#34;test1.js&amp;#34; const hello = &amp;#39;hello world&amp;#39;; function plus(a, b) { return a + b; } class Animal { constructor(name) { this.</description></item><item><title>Node.js 與 MongoDB 學習筆記</title><link>https://sayoko123f.github.io/testgo/p/node-use-mongodb/</link><pubDate>Tue, 15 Mar 2022 18:20:26 +0800</pubDate><guid>https://sayoko123f.github.io/testgo/p/node-use-mongodb/</guid><description>Node.js 與 MongoDB 學習筆記 本筆記主要會記錄在 Node.js 應用中連接 MongoDB Atlas 的操作方法，如果讀者發現任何錯誤或值得討論的地方，請不吝指教。
環境為 Node.js v14.17.4，MongoDB 是在 MongoDB Atlas 申請 shared 的免費方案。
文件 MongoDB 手冊 MongoDB Node.js driver MongoDB NoDe.js driver API 準備 安裝驅動 npm
npm i mongodb 建立測試資料 MongoDB Atlas 有提供一組資料集可以用來測試練習，在控制台按 Load Sample Dataset 就可以載入了，可參考這裡有一篇鐵人賽關於建立 Atlas 的教學寫得很詳細，。另外本文也在 sample_airbnb 資料庫底下建立了一個空的資料集名為 practiceData。
連接 連接需要一組 uri ，在 MongoDB 的控制台可以複製，本文會使用帳號密碼的方式連接，至於使用證書連接的方式，則待日後再研究了。
假設密碼放在父目錄的 .env json 檔案，注意帳號密碼如果有特殊字元要使用 encodeURIComponent進行編碼。
下方程式碼為進行連接，以及關閉。
const fs = require(&amp;#39;fs&amp;#39;); const path = require(&amp;#39;path&amp;#39;); const env = JSON.</description></item><item><title>我在 Github 上第一個開源貢獻</title><link>https://sayoko123f.github.io/testgo/p/my-first-issue/</link><pubDate>Tue, 04 Jan 2022 11:34:56 +0800</pubDate><guid>https://sayoko123f.github.io/testgo/p/my-first-issue/</guid><description>我在 Github 上第一個開源貢獻 flowbite/issue#53
經過 flowbite 是一個 tailwindcss 的元件庫。
在某個研究 CSS 的晚上，我發現它的 Navbar 上面都有一個奇怪的類名 hover:bg-gray-100focus:outline-none，仔細看就會發現它少了一個空格，而且這樣的類名有四個，但是當下我是先懷疑是不是我的 tailwind 還學的不夠到位，不知道有這種用法。
反覆翻過文件後，確定沒有這種用法而是一個錯誤後，我內心就開始小劇場：「怎麼辦，是要開個 issue 嗎，但要用英文溝通很恐懼，還是提交一個 PR，但這樣會不會太唐突？」
後來就決定用 issue 發問，結果等了好幾天都沒有回應。
六天之後的晚上作者終於回應了！作者回應表示「謝謝你發現這個錯誤，如果願意你可以提交一個 PR ，或是我之後會自己修正」。
因為離作者回應已經過約八小時我才看到訊息，檢查一下 commit 發現作者已經修正了，所以就沒提交到 PR ，但還是可喜可賀。
至於作者慢回的原因，我懷疑是因為剛好遇到聖誕節，聖誕節後接著跨年，作者很可能是狂歡去了XD
當初學程式的時候從來沒想過我會有用英文跟外國大佬討論的一天，更何況改他的程式碼，雖然這個 issue 只是指出四個空白鍵的小錯誤，但這也是我在程式界邁出的一大步！(在誇張什麼啦XD) 。
反思 會產生這種少了空白的 BUG ，其實和順風的設計有很大的關係，因為在寫順風的時候常常會寫出一坨很長的類名，雖然寫的時候很快，但是日後維護起來可讀性比較差。
有消息順風官方似乎有在開發 prettier-plugin ，希望能解決這個問題。</description></item><item><title>JavaScript 關於錯誤處理與自訂錯誤類別</title><link>https://sayoko123f.github.io/testgo/p/javascript-error/</link><pubDate>Sun, 10 Oct 2021 11:49:39 +0800</pubDate><guid>https://sayoko123f.github.io/testgo/p/javascript-error/</guid><description>JavaScript 關於錯誤處理與自訂錯誤類別 關於錯誤 在 JavaScript 中，內建有 Error 類別，詳細請見 MDN。先來看看錯誤長什麼樣子，下方程式碼引發一個 SyntaxError
JSON.parse(&amp;#39;foo&amp;#39;); 在主控台會看到這段訊息
VM252:1 Uncaught SyntaxError: Unexpected token o in JSON at position 1 at JSON.parse (&amp;lt;anonymous&amp;gt;) at test.js:1 捕捉錯誤並檢視訊息 可利用 try/catch 語句捕捉錯誤，錯誤物件的 name 和 message 特性包含錯誤的名字與訊息，toString() 方法會回傳一段包含 name 跟 message 的字串。如果想要檢視呼叫堆疊，可以使用 console.trace() 。
try { JSON.parse(&amp;#39;foo&amp;#39;); } catch (err) { console.log(err.name); // SyntaxError console.log(err.message); // Unexpected token o in JSON at position 1 console.log(err.toString()); // SyntaxError: Unexpected token o in JSON at position 1 console.</description></item><item><title>PHP echo 在命令列輸出彩色文字</title><link>https://sayoko123f.github.io/testgo/p/php-echo-color/</link><pubDate>Wed, 22 Sep 2021 13:59:40 +0800</pubDate><guid>https://sayoko123f.github.io/testgo/p/php-echo-color/</guid><description>PHP echo 在命令列輸出彩色文字 以下是土法炮製，已在我的 Windows 10 上實測可行(PHP 7)。
&amp;lt;?php echo echocolor(&amp;#34;Hello World&amp;#34;, 30) . PHP_EOL; echo echocolor(&amp;#34;Hello World&amp;#34;, 31) . PHP_EOL; echo echocolor(&amp;#34;Hello World&amp;#34;, 32) . PHP_EOL; echo echocolor(&amp;#34;Hello World&amp;#34;, 33) . PHP_EOL; echo echocolor(&amp;#34;Hello World&amp;#34;, 34) . PHP_EOL; echo echocolor(&amp;#34;Hello World&amp;#34;, 35) . PHP_EOL; echo echocolor(&amp;#34;Hello World&amp;#34;, 36) . PHP_EOL; echo echocolor(&amp;#34;Hello World&amp;#34;, 37) . PHP_EOL; echo echocolor(&amp;#34;Hello World&amp;#34;, 90) . PHP_EOL; echo echocolor(&amp;#34;Hello World&amp;#34;, 91) . PHP_EOL; echo echocolor(&amp;#34;Hello World&amp;#34;, 92) .</description></item><item><title>在 Vue 中 data, method, computed 的使用時機</title><link>https://sayoko123f.github.io/testgo/p/vue-using-data-method-or-computed/</link><pubDate>Wed, 22 Sep 2021 13:59:40 +0800</pubDate><guid>https://sayoko123f.github.io/testgo/p/vue-using-data-method-or-computed/</guid><description>在 Vue 中 data, method, computed 的使用時機 資料(Data)和方法(Method)以及計算屬性(computed)是 Vue 物件中常常用來存放資料的地方，然而什麼時候該用哪一種，是在剛開始學的時候會疑惑的一個問題，以下對這三者做整理分析：
比較 // Example in component export default { data: () =&amp;gt; ({ nums: [1, 2, 3, 4] }), computed: { sumNums() { return this.nums.reduce((acc, cur)=&amp;gt; acc + cur); } }, methods: { multNums(n) { return this.nums.map(e=&amp;gt; e * n); } } }; Data 資料 Data 物件很單純，適合用來放資料，以供後續其他地方使用。
Computed 計算屬性 Computed 計算屬性比較特別，它的性質介於 Data 和 Method 之間，在宣告的時候它長得像函式，但使用的時候不用加小括號。</description></item><item><title>JavaScript Onbeforeunload</title><link>https://sayoko123f.github.io/testgo/p/javascript-onbeforeunload/</link><pubDate>Fri, 21 May 2021 09:34:20 +0800</pubDate><guid>https://sayoko123f.github.io/testgo/p/javascript-onbeforeunload/</guid><description>在離開頁面之前詢問使用者是否要離開 WindowEventHandlers.onbeforeunload MDN
window.onbeforeunload 這樣寫即可。
window.onbeforeunload = function () { return &amp;#34;&amp;#34;; } 為防止詐騙，各大瀏覽器已不支援自訂訊息 // Deprecated window.onbeforeunload = function() { if(!confirm(&amp;#39;您確定要離開網頁嗎？&amp;#39;)) { return false; } } 在以前可能會這樣寫，雖然這樣寫功能仍可以正常運作，但為了防止詐騙，現在瀏覽器已經不支援自訂訊息了，所以只會看到瀏覽器預設的訊息。</description></item><item><title>JavaScript 如何動態地插入元素至 DOM</title><link>https://sayoko123f.github.io/testgo/p/javascript-insert-element-to-dom/</link><pubDate>Thu, 20 May 2021 09:52:56 +0800</pubDate><guid>https://sayoko123f.github.io/testgo/p/javascript-insert-element-to-dom/</guid><description>如何動態地插入元素至 DOM 先備知識 建議已經對 HTML DOM 有基本了解的讀者再閱讀底下內容。
節點關係 考慮以下 HTML：&amp;lt;body&amp;gt; 底下有 id=&amp;quot;box&amp;quot; 的 &amp;lt;div&amp;gt;，底下又有 4 顆 button。 button 在 div 底下，所以 button 是 div 的子節點， div 是 button 的父節點，稱為父子關係。而 4顆 button 之間彼此是兄弟關係。
&amp;lt;!DOCTYPE html&amp;gt; &amp;lt;html&amp;gt; &amp;lt;head&amp;gt; &amp;lt;meta charset=&amp;#34;UTF-8&amp;#34;&amp;gt; &amp;lt;title&amp;gt;Document&amp;lt;/title&amp;gt; &amp;lt;/head&amp;gt; &amp;lt;body&amp;gt; &amp;lt;div id=&amp;#34;box&amp;#34;&amp;gt; &amp;lt;button id=&amp;#34;btn1&amp;#34;&amp;gt;btn1&amp;lt;/button&amp;gt; &amp;lt;button id=&amp;#34;btn2&amp;#34;&amp;gt;btn2&amp;lt;/button&amp;gt; &amp;lt;button id=&amp;#34;btn3&amp;#34;&amp;gt;btn3&amp;lt;/button&amp;gt; &amp;lt;button id=&amp;#34;btn4&amp;#34;&amp;gt;btn4&amp;lt;/button&amp;gt; &amp;lt;/div&amp;gt; &amp;lt;/body&amp;gt; &amp;lt;/html&amp;gt; 透過父子關係或兄弟關係選擇元素 繼續用上面的 HTML：
let box = document.</description></item><item><title>SQL Fiddle - 好用的 SQL 線上測試&amp;練習工具</title><link>https://sayoko123f.github.io/testgo/p/sql-fiddle/</link><pubDate>Thu, 20 May 2021 09:52:56 +0800</pubDate><guid>https://sayoko123f.github.io/testgo/p/sql-fiddle/</guid><description>SQL Fiddle - 好用的 SQL 線上測試&amp;amp;練習 工具 SQL Fiddle 是一個線上網站，不用註冊隨進隨用，一進去它會產生一個已經建好的資料庫，只需要從 CREATE TABLE 開始就好了，
支援資料庫版本 資料庫 版本 ORACLE 11g R2 SQL Server 2017 MySQL 5.6 PostgreSQL 9.6 PostgreSQL 9.3 SQLite WebSQL SQLite SQL.js 功能 建立 Schema 運行 SQL 指令 分享連結 分享連結的功能是在 Build 之後會得到一個連結，可以把 SQL 分享出去。儲存時間似乎是沒有限制，我點網路上 2012 年的連結都還正常。</description></item><item><title>如何使用 JavaScript 切換元素的 class</title><link>https://sayoko123f.github.io/testgo/p/javascript-toggle-class/</link><pubDate>Thu, 13 May 2021 10:16:52 +0800</pubDate><guid>https://sayoko123f.github.io/testgo/p/javascript-toggle-class/</guid><description>如何使用 JavaScript 切換元素的 class 利用 element.classList即可，底下來看看如何使用：
&amp;lt;!-- html --&amp;gt; &amp;lt;p id=&amp;#34;p1&amp;#34;&amp;gt;Hello World!&amp;lt;/p&amp;gt; /* css */ .blue{ color: blue; } .red{ color: red; } .green{ color: green; } element.classList element.classList 包含了這個元素所有的類別名稱的物件。
let p1 = document.getElementById(&amp;#39;p1&amp;#39;); // 後面的範例都省略這行 p1.classList; // { length: 0, value: &amp;#34;&amp;#34;} p1.classList.length === 0; // true p1.classList.add(&amp;#39;red&amp;#39;); p1.classList; // {0: &amp;#34;red&amp;#34;, length: 1, value: &amp;#34;red&amp;#34;} p1.classList[0]; // &amp;#34;red&amp;#34; classList.add(classname) 傳入類別名稱就會添加類別至元素上，如果已經有了則什麼事都不會發生。
p1.classList.add(&amp;#39;blue&amp;#39;); classList.contains(classname) 傳入類別名稱，傳回 boolean，如果存在該類名就是 true，反之 false。</description></item><item><title>scp - 使用 ssh 在主機間複製傳送檔案</title><link>https://sayoko123f.github.io/testgo/p/scp-command-note/</link><pubDate>Sun, 09 May 2021 16:06:09 +0800</pubDate><guid>https://sayoko123f.github.io/testgo/p/scp-command-note/</guid><description>scp 指令 scp 是在 ssh 的基礎上運作的，所以必須先安裝 ssh 。
將檔案由本地複製到遠端主機 scp [filename] [account]@[remote]:[path] filename: 欲複製的檔案名稱 account: 遠端主機使用者名稱 remote: IP 位址或 Domain path: 檔案存放於遠端主機的路徑 範例：底下指令會將現有目錄內的 foo.txt 複製至主機 example.com 的 hello 使用者家目錄底下的 data 資料夾
scp foo.txt hello@example.com:~/data/foo.txt 將檔案由遠端主機複製至本地 scp [account]@[remote]:[path] [localPath] 範例：底下指令會將遠端主機 example.com內的 hello 使用者家目錄底下的 data 資料夾的 foo.txt 複製至現在工作目錄。
scp hello@example.com:~/data/foo.txt . 修改 port ssh 預設 port 為 22，如果要修改就加上 -P
scp -P 2222 複製資料夾及底下所有檔案 scp -r /path/folder hello@example.com:/path/folder2 參考 https://man.</description></item><item><title>Test5</title><link>https://sayoko123f.github.io/testgo/p/test5/</link><pubDate>Fri, 02 Apr 2021 16:47:56 +0800</pubDate><guid>https://sayoko123f.github.io/testgo/p/test5/</guid><description>Test5 測試測試測試測試測試測試測試測試測試測試測試測試測試測試測試，測試測試測試測試測試測試測試測試測試。</description></item><item><title>PHP PDO 連接資料庫筆記</title><link>https://sayoko123f.github.io/testgo/p/php-pdo-connect-database/</link><pubDate>Sat, 16 Jan 2021 17:02:09 +0800</pubDate><guid>https://sayoko123f.github.io/testgo/p/php-pdo-connect-database/</guid><description>PHP PDO 連接資料庫筆記 PHP PDO Manual
try { $host = &amp;#34;localhost&amp;#34;; $db_name = &amp;#34;test&amp;#34;; $db_user = &amp;#34;test&amp;#34;; $db_password = &amp;#34;123&amp;#34;; $con = new PDO(&amp;#34;mysql:host=$host;dbname=$db_name;charset=utf8&amp;#34;, $db_user, $db_password); $con-&amp;gt;setAttribute(PDO::ATTR_ERRMODE, PDO::ERRMODE_EXCEPTION); } catch (\PDOException $e) { die(&amp;#34;Failed to connect database: &amp;#34; . $e-&amp;gt;getMessage()); } 其中 $con-&amp;gt;setAttribute(PDO::ATTR_ERRMODE, PDO::ERRMODE_EXCEPTION); 這行是指設置錯誤模式。</description></item><item><title>我的 Git 小抄</title><link>https://sayoko123f.github.io/testgo/p/git-note/</link><pubDate>Sat, 16 Jan 2021 17:02:09 +0800</pubDate><guid>https://sayoko123f.github.io/testgo/p/git-note/</guid><description>我的 Git 小抄 clone 使用 git clone 下載專案
git clone https://github.com/Sayoko123f/cmx.git 指定分支
git clone &amp;lt;repo URL&amp;gt; -b &amp;lt;branch name&amp;gt; 放棄本地更改並復原 查詢版本歷史記錄
git log --oneline -n 保留現在檔案內容更改，僅還原 HEAD
git reset HEAD git reset &amp;lt;SHA-1編號&amp;gt; 不保留現在的內容更改，復原檔案內容(小心使用)
git reset --hard HEAD 復原到最近的 commit git reset --hard HEAD~ 等於 ~1 回復到上一個提交版本 git reset --hard HEAD~n n 等於往上第幾個提交版本 回復之前指定的提交版本 指定特定分支
git reset --hard origin/&amp;lt;branch name&amp;gt; checkout 切換分支 git checkout &amp;lt;branch name&amp;gt; 在 checkout 命令給定 -b 參數執行，可以同時建立分支和切換。</description></item></channel></rss>